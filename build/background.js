(()=>{"use strict";async function e(){const e=await chrome.storage.local.get(["wallets","selectedWallet"]),t=e.wallets||[],n=e.selectedWallet;return 0===t.length?[]:n&&t.find(e=>e.address===n.address)?[n.address]:[t[0].address]}(new class{constructor(){this.pendingRequests=new Map,this.connectedSites=new Set}async initialize(){const e=await chrome.storage.local.get(["connectedSites"]);if(e.connectedSites){const t=e.connectedSites.reduce((e,t)=>{const n=e.find(e=>e.url===t.url);if(n){if(t.lastUsed>n.lastUsed){const s=e.indexOf(n);e[s]=t}}else e.push(t);return e},[]);t.length!==e.connectedSites.length&&await chrome.storage.local.set({connectedSites:t}),t.forEach(e=>{this.connectedSites.add(e.url)})}chrome.runtime.onMessage.addListener((e,t,n)=>(this.handleMessage(e,t,n),!0)),chrome.action.onClicked.addListener(()=>{this.openPopupForPendingRequest()})}async handleMessage(e,t,n){const{type:s,data:a}=e,c=t.origin||t.url?.split("/").slice(0,3).join("/")||"";if(c)switch(s){case"ETH_REQUEST_ACCOUNTS":case"ETH_REQUEST":await this.handleEthRequest(c,a,n);break;case"ETH_SEND_TRANSACTION":await this.handleTransactionRequest(c,a,n);break;case"ETH_SIGN_MESSAGE":n({error:"Sign message not implemented yet"});break;case"CHECK_CONNECTION":await this.handleCheckConnection(c,n);break;case"CONNECTION_APPROVED":await this.approveConnection(a.requestId,a.account,a.chainId),n({success:!0});break;case"CONNECTION_REJECTED":await this.rejectConnection(a.requestId),n({success:!0});break;case"WALLETCONNECT_PAIR":await this.handleWalletConnectPair(a.uri,n);break;case"DISCONNECT_DAPP":await this.handleDisconnectDApp(a.url,n);break;case"CHAIN_CHANGED":await this.handleChainChanged(a.chainId,n);break;default:n({error:"Unknown request type"})}else n({error:"Invalid origin"})}async handleEthRequest(e,t,n){const{method:s,params:a}=t;"eth_requestAccounts"===s?await this.handleAccountsRequest(e,t,n):n({error:`Method ${s} not implemented yet`})}async handleCheckConnection(e,t){if(this.connectedSites.has(e)){const n=(await this.getConnectedSites()).find(t=>t.url===e);if(n)return void t({connected:!0,account:n.account,chainId:`0x${n.chainId.toString(16)}`})}t({connected:!1})}async handleAccountsRequest(e,t,n){if(this.connectedSites.has(e)){const t=(await this.getConnectedSites()).find(t=>t.url===e);if(t){const s=await this.getCurrentSelectedAccount(),a=s.length>0?s[0]:null;if(a){const s=(await chrome.storage.local.get([`dapp_${e}`]))[`dapp_${e}`];if(s&&s.connectedAddresses?.includes(a))return void n({accounts:[a],chainId:`0x${t.chainId.toString(16)}`})}return void n({accounts:[t.account],chainId:`0x${t.chainId.toString(16)}`})}}const s=`req_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,a={id:s,origin:e,siteName:t.siteName||new URL(e).hostname,siteIcon:t.siteIcon,method:"eth_requestAccounts",timestamp:Date.now()};this.pendingRequests.set(s,a),await this.showConnectionPopup(a),this.storePendingResponse(s,n)}async handleTransactionRequest(e,t,n){if(!this.connectedSites.has(e))return void n({error:"Not connected to this site"});const s=`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;await this.showTransactionPopup(e,t,s),this.storePendingResponse(s,n)}async showConnectionPopup(e){await chrome.storage.local.set({appState:{currentScreen:"connect-dapp",connectDAppRequest:{requestId:e.id,siteUrl:e.origin,siteName:e.siteName,siteIcon:e.siteIcon}}}),await chrome.action.openPopup()}async showTransactionPopup(e,t,n){await chrome.storage.local.set({pendingTransaction:{requestId:n,origin:e,txData:t,timestamp:Date.now()}}),await chrome.storage.local.set({appState:{currentScreen:"send-eth",sendEthState:{recipientAddress:t.to||"",amount:t.value?(parseInt(t.value,16)/1e18).toString():"",recipientName:""}}}),await chrome.action.openPopup()}async approveConnection(e,t,n){const s=this.pendingRequests.get(e);if(!s)return;this.connectedSites.add(s.origin);const a=await this.getConnectedSites(),c=a.findIndex(e=>e.url===s.origin),o={url:s.origin,name:s.siteName,icon:s.siteIcon,connectedAt:c>=0?a[c].connectedAt:Date.now(),lastUsed:Date.now(),permissions:["eth_accounts"],chainId:n,account:t};c>=0?a[c]=o:a.push(o),await chrome.storage.local.set({connectedSites:a});const i=`dapp_${s.origin}`,r=(await chrome.storage.local.get([i]))[i]||{};r.connectedAddresses||(r.connectedAddresses=[]),r.connectedAddresses.includes(t)||r.connectedAddresses.push(t),r.connected=!0,r.chainId=n,r.lastUsed=Date.now(),await chrome.storage.local.set({[i]:r});const d=this.getPendingResponse(e);d&&d({accounts:[t],chainId:`0x${n.toString(16)}`}),await this.notifyContentScript(s.origin,{type:"CONNECTION_SUCCESS",data:{account:t,chainId:`0x${n.toString(16)}`}}),this.pendingRequests.delete(e)}async rejectConnection(e){if(!this.pendingRequests.get(e))return;const t=this.getPendingResponse(e);t&&t({error:"User rejected the request"}),this.pendingRequests.delete(e)}async getConnectedSites(){return(await chrome.storage.local.get(["connectedSites"])).connectedSites||[]}async getCurrentSelectedAccount(){const e=await chrome.storage.local.get(["wallets","selectedWallet"]),t=e.wallets||[],n=e.selectedWallet;return 0===t.length?[]:n&&t.find(e=>e.address===n.address)?[n.address]:[t[0].address]}storePendingResponse(e,t){globalThis.pendingResponses=globalThis.pendingResponses||new Map,globalThis.pendingResponses.set(e,t)}getPendingResponse(e){const t=globalThis.pendingResponses,n=t?.get(e);return n&&t.delete(e),n}async notifyContentScript(e,t){try{const n=await chrome.tabs.query({url:`${e}/*`});for(const e of n)e.id&&chrome.tabs.sendMessage(e.id,t).catch(()=>{})}catch(e){console.error("Error notifying content script:",e)}}async openPopupForPendingRequest(){if(this.pendingRequests.size>0){const e=Array.from(this.pendingRequests.values())[0];await this.showConnectionPopup(e)}}async handleWalletConnectPair(e,t){try{if(!e.startsWith("wc:")||!e.includes("@")||!e.includes("?"))return void t({success:!1,error:"Invalid WalletConnect URI format"});const n=`wc_${Date.now()}`,[s,a]=e.split(":"),[c,o]=a.split("@"),[i,r]=o.split("?");await chrome.storage.local.set({[`walletconnect_${n}`]:{uri:e,sessionId:c,version:i,params:r,connectedAt:Date.now(),active:!0}});const d=await this.getConnectedSites(),l={url:`walletconnect://${c}`,name:"WalletConnect Session",icon:void 0,permissions:["eth_accounts"],chainId:1,account:"",connectedAt:Date.now(),lastUsed:Date.now(),isWalletConnect:!0,wcSessionId:n};d.push(l),await chrome.storage.local.set({connectedSites:d}),t({success:!0,message:"WalletConnect session established",sessionId:n})}catch(e){console.error("WalletConnect pairing error:",e),t({success:!1,error:"Failed to establish WalletConnect session"})}}async handleDisconnectDApp(e,t){try{this.connectedSites.delete(e);const n=(await this.getConnectedSites()).filter(t=>t.url!==e);await chrome.storage.local.set({connectedSites:n}),await this.notifyContentScript(e,{type:"WALLET_DISCONNECTED",data:{}}),t({success:!0})}catch(e){console.error("Error disconnecting dApp:",e),t({error:"Failed to disconnect dApp"})}}async handleChainChanged(e,t){try{let n;n="string"==typeof e?e.startsWith("0x")?parseInt(e,16):parseInt(e,10):e;const s=`0x${n.toString(16)}`,a=await this.getConnectedSites(),c=a.map(e=>({...e,chainId:n,lastUsed:Date.now()}));await chrome.storage.local.set({connectedSites:c});for(const e of a)e.url.startsWith("walletconnect://")||await this.notifyContentScript(e.url,{type:"CHAIN_CHANGED",data:{chainId:s}});t({success:!0})}catch(e){console.error("Error handling chain change:",e),t({error:"Failed to handle chain change"})}}}).initialize(),chrome.runtime.onInstalled.addListener(()=>{console.log("clearWallet extension installed")}),chrome.runtime.onMessage.addListener((t,n,s)=>{switch(t.type){case"GET_WALLET_STATE":return async function(t){try{const n=await e();t({success:!0,data:{isConnected:n.length>0,accounts:n,chainId:"0x1"}})}catch(e){t({success:!1,error:"Failed to get wallet state"})}}(s),!0;case"SIGN_TRANSACTION":return async function(e,t){try{t({success:!0,data:{signature:"0x"+"0".repeat(130)}})}catch(e){t({success:!1,error:"Failed to sign transaction"})}}(t.data,s),!0;case"GET_ACCOUNTS":return async function(t){try{t({success:!0,data:await e()})}catch(e){t({success:!1,error:"Failed to get accounts"})}}(s),!0;case"REQUEST_ACCOUNTS":return async function(t){try{const n=await e();if(0===n.length)return chrome.action.openPopup(),void t({success:!1,error:"User rejected the request"});t({success:!0,data:n})}catch(e){t({success:!1,error:"Failed to request accounts"})}}(s),!0;default:console.log("Unknown message type:",t.type)}}),chrome.runtime.onConnect.addListener(t=>{"clearwallet-provider"===t.name&&t.onMessage.addListener(async n=>{const{id:s,method:a,params:c}=n;try{let n;switch(a){case"eth_requestAccounts":const t=await e();n=t.length>0?t:await async function(){return await e()}();break;case"eth_accounts":n=await e();break;case"eth_chainId":n="0x1";break;case"net_version":n="1";break;case"personal_sign":case"eth_sign":n=await async function(){return"0x"+"0".repeat(130)}();break;case"eth_sendTransaction":n=await async function(){return"0x"+"0".repeat(64)}(c[0]);break;default:throw new Error(`Unsupported method: ${a}`)}t.postMessage({id:s,result:n,error:null})}catch(e){t.postMessage({id:s,result:null,error:{code:-32e3,message:e.message}})}})})})();