(()=>{"use strict";const e={autoLock:!0,lockTimeout:9e5,showTestnets:!1,defaultGasLimit:21e3,currency:"USD"};class t{constructor(){this.cache=new Map,this.STORAGE_VERSION=1}static getInstance(){return t.instance||(t.instance=new t),t.instance}async get(e){try{if(this.cache.has(e))return this.cache.get(e);const t=(await chrome.storage.local.get([e]))[e]||null;return null!==t&&this.cache.set(e,t),t}catch(t){return console.error(`StorageService: Error getting ${e}:`,t),null}}async set(e,t){try{await chrome.storage.local.set({[e]:t}),this.cache.set(e,t),console.log(`StorageService: Set ${e}:`,t)}catch(t){throw console.error(`StorageService: Error setting ${e}:`,t),t}}async getMultiple(e){try{const t=await chrome.storage.local.get(e),r={};return e.forEach(e=>{void 0!==t[e]&&(this.cache.set(e,t[e]),r[e]=t[e])}),r}catch(e){return console.error("StorageService: Error getting multiple values:",e),{}}}async setMultiple(e){try{await chrome.storage.local.set(e),Object.entries(e).forEach(([e,t])=>{this.cache.set(e,t)}),console.log("StorageService: Set multiple values:",Object.keys(e))}catch(e){throw console.error("StorageService: Error setting multiple values:",e),e}}async remove(e){try{await chrome.storage.local.remove([e]),this.cache.delete(e),console.log(`StorageService: Removed ${e}`)}catch(t){throw console.error(`StorageService: Error removing ${e}:`,t),t}}async clear(){try{await chrome.storage.local.clear(),this.cache.clear(),console.log("StorageService: Cleared all storage")}catch(e){throw console.error("StorageService: Error clearing storage:",e),e}}async initialize(){try{const t=await this.get("version");t?t<this.STORAGE_VERSION&&await this.runMigrations(t,this.STORAGE_VERSION):(await this.setMultiple({networks:[],customNetworks:[],selectedNetwork:null,selectedRpcs:{},wallets:[],selectedWallet:null,connectedSites:[],settings:e,version:this.STORAGE_VERSION,lastMigration:Date.now()}),console.log("StorageService: Initialized with defaults"))}catch(e){throw console.error("StorageService: Error during initialization:",e),e}}async runMigrations(e,t){console.log(`StorageService: Running migrations from v${e} to v${t}`),await this.set("version",t),await this.set("lastMigration",Date.now())}clearCache(){this.cache.clear(),console.log("StorageService: Cache cleared")}getCacheInfo(){return{size:this.cache.size,keys:Array.from(this.cache.keys())}}}class r{constructor(){this.listeners=new Map,this.storageService=t.getInstance()}static getInstance(){return r.instance||(r.instance=new r),r.instance}async getAllNetworks(){const[e,t]=await Promise.all([this.storageService.get("networks"),this.storageService.get("customNetworks")]);return[...e||[],...t||[]]}async getBuiltInNetworks(){return await this.storageService.get("networks")||[]}async getCustomNetworks(){return await this.storageService.get("customNetworks")||[]}async getSelectedNetwork(){return await this.storageService.get("selectedNetwork")}async switchNetwork(e){try{const t=await this.getSelectedNetwork();let r=null;if("object"==typeof e)r=e;else{const t="string"==typeof e?this.parseChainId(e):e;r=await this.findNetworkByChainId(t)}if(!r)throw new Error("Network not found");await this.storageService.set("selectedNetwork",r);const a={oldNetwork:t,newNetwork:r,chainId:r.chainId,chainIdHex:this.chainIdToHex(r.chainId)};return this.emit("networkChanged",a),console.log(`NetworkManager: Switched to ${r.name} (${r.chainId})`),a}catch(e){throw console.error("NetworkManager: Error switching network:",e),e}}async addCustomNetwork(e){try{const t=this.parseChainId(e.chainId);if(await this.findNetworkByChainId(t))throw new Error(`Network with chainId ${t} already exists`);const r={id:`custom-${t}`,name:e.chainName,chainId:t,blockExplorer:e.blockExplorerUrls?.[0]||"",rpc:e.rpcUrls.map((e,t)=>({name:0===t?"Default":`RPC ${t+1}`,url:e})),isTestnet:1!==t&&8453!==t,isCustom:!0},a=await this.getCustomNetworks();return await this.storageService.set("customNetworks",[...a,r]),console.log(`NetworkManager: Added custom network ${r.name}`),r}catch(e){throw console.error("NetworkManager: Error adding custom network:",e),e}}async removeCustomNetwork(e){try{const t=(await this.getCustomNetworks()).filter(t=>t.chainId!==e);await this.storageService.set("customNetworks",t);const r=await this.getSelectedNetwork();if(r&&r.chainId===e){const e=await this.getBuiltInNetworks();e.length>0&&await this.switchNetwork(e[0])}console.log(`NetworkManager: Removed custom network with chainId ${e}`)}catch(e){throw console.error("NetworkManager: Error removing custom network:",e),e}}async findNetworkByChainId(e){return(await this.getAllNetworks()).find(t=>t.chainId===e)||null}async getSelectedRpc(e){const t=await this.storageService.get("selectedRpcs")||{},r=await this.findNetworkById(e);return t[e]||r?.rpc[0]||null}async setSelectedRpc(e,t){const r=await this.storageService.get("selectedRpcs")||{};r[e]=t,await this.storageService.set("selectedRpcs",r)}parseChainId(e){const t=e.startsWith("0x")?parseInt(e,16):parseInt(e,10);if(isNaN(t))throw new Error(`Invalid chainId: ${e}`);return t}chainIdToHex(e){return`0x${e.toString(16)}`}async isBuiltInNetwork(e){return(await this.getBuiltInNetworks()).some(t=>t.chainId===e)}async findNetworkById(e){return(await this.getAllNetworks()).find(t=>t.id===e)||null}on(e,t){this.listeners.has(e)||this.listeners.set(e,[]),this.listeners.get(e).push(t)}off(e,t){const r=this.listeners.get(e);if(r){const e=r.indexOf(t);e>-1&&r.splice(e,1)}}emit(e,t){const r=this.listeners.get(e);r&&r.forEach(r=>{try{r(t)}catch(t){console.error(`NetworkManager: Error in event listener for ${e}:`,t)}})}}class a{constructor(){this.listeners=new Map,this.storageService=t.getInstance()}static getInstance(){return a.instance||(a.instance=new a),a.instance}async getAllWallets(){return await this.storageService.get("wallets")||[]}async getSelectedWallet(){return await this.storageService.get("selectedWallet")}async getWalletById(e){return(await this.getAllWallets()).find(t=>t.id===e)||null}async getWalletByAddress(e){return(await this.getAllWallets()).find(t=>t.address.toLowerCase()===e.toLowerCase())||null}async createWallet(e){try{const t=await this.generateWalletData(e);if(await this.getWalletByAddress(t.address))throw new Error("Wallet with this address already exists");const r={id:this.generateWalletId(),name:e.name||this.generateWalletName(e.type),address:t.address,type:e.type,derivationPath:e.derivationPath,publicKey:t.publicKey,createdAt:Date.now(),lastUsed:Date.now()},a=await this.getAllWallets();return a.push(r),await this.storageService.set("wallets",a),await this.getSelectedWallet()||await this.selectWallet(r.id),await this.storeWalletSecret(r.id,t.privateKey),this.emit("walletAdded",{type:"walletAdded",wallet:r}),console.log(`WalletManager: Created ${e.type} wallet ${r.name}`),r}catch(e){throw console.error("WalletManager: Error creating wallet:",e),e}}async importFromPrivateKey(e,t){return this.createWallet({type:"imported",privateKey:e,name:t})}async importFromMnemonic(e,t,r){return this.createWallet({type:"imported",mnemonic:e,name:t,derivationPath:r||"m/44'/60'/0'/0/0"})}async generateWallet(e){return this.createWallet({type:"generated",name:e})}async selectWallet(e){try{const t=await this.getWalletById(e);if(!t)throw new Error(`Wallet with ID ${e} not found`);const r=await this.getSelectedWallet();t.lastUsed=Date.now(),await this.updateWallet(t),await this.storageService.set("selectedWallet",t),this.emit("walletSelected",{type:"walletSelected",wallet:t,oldWallet:r||void 0}),console.log(`WalletManager: Selected wallet ${t.name}`)}catch(e){throw console.error("WalletManager: Error selecting wallet:",e),e}}async updateWallet(e){try{const t=await this.getAllWallets(),r=t.findIndex(t=>t.id===e.id);if(-1===r)throw new Error(`Wallet with ID ${e.id} not found`);t[r]=e,await this.storageService.set("wallets",t);const a=await this.getSelectedWallet();a&&a.id===e.id&&await this.storageService.set("selectedWallet",e),console.log(`WalletManager: Updated wallet ${e.name}`)}catch(e){throw console.error("WalletManager: Error updating wallet:",e),e}}async renameWallet(e,t){try{const r=await this.getWalletById(e);if(!r)throw new Error(`Wallet with ID ${e} not found`);const a={...r};r.name=t,await this.updateWallet(r),this.emit("walletRenamed",{type:"walletRenamed",wallet:r,oldWallet:a}),console.log(`WalletManager: Renamed wallet to ${t}`)}catch(e){throw console.error("WalletManager: Error renaming wallet:",e),e}}async removeWallet(e){try{const t=await this.getWalletById(e);if(!t)throw new Error(`Wallet with ID ${e} not found`);const r=(await this.getAllWallets()).filter(t=>t.id!==e);await this.storageService.set("wallets",r);const a=await this.getSelectedWallet();a&&a.id===e&&(r.length>0?await this.selectWallet(r[0].id):await this.storageService.set("selectedWallet",null)),await this.removeWalletSecret(e),this.emit("walletRemoved",{type:"walletRemoved",wallet:t}),console.log(`WalletManager: Removed wallet ${t.name}`)}catch(e){throw console.error("WalletManager: Error removing wallet:",e),e}}async getWalletPrivateKey(e){try{throw new Error("Private key retrieval not yet implemented")}catch(e){throw console.error("WalletManager: Error getting private key:",e),e}}async isWalletLocked(){return!1}async lockWallets(){console.log("WalletManager: Wallets locked")}async unlockWallets(e){return console.log("WalletManager: Wallets unlocked"),!0}async generateWalletData(e){return e.privateKey?{address:"0x"+"1".repeat(40),privateKey:e.privateKey}:e.mnemonic?{address:"0x"+"2".repeat(40),privateKey:"0x"+"a".repeat(64)}:{address:"0x"+"3".repeat(40),privateKey:"0x"+"b".repeat(64)}}generateWalletId(){return"wallet-"+Date.now()+"-"+Math.random().toString(36).substr(2,9)}generateWalletName(e){return`${"imported"===e?"Imported":"Wallet"} ${(new Date).toLocaleString()}`}async storeWalletSecret(e,t){console.log(`WalletManager: Storing secret for wallet ${e}`)}async removeWalletSecret(e){console.log(`WalletManager: Removing secret for wallet ${e}`)}on(e,t){this.listeners.has(e)||this.listeners.set(e,[]),this.listeners.get(e).push(t)}off(e,t){const r=this.listeners.get(e);if(r){const e=r.indexOf(t);e>-1&&r.splice(e,1)}}emit(e,t){const r=this.listeners.get(e);r&&r.forEach(r=>{try{r(t)}catch(t){console.error(`WalletManager: Error in event listener for ${e}:`,t)}})}}const s=-32602,n=-32603,i=4100,o=5004;class c{constructor(){this.handlers=new Map,this.networkManager=r.getInstance(),this.storageService=t.getInstance(),this.registerBuiltInMethods()}static getInstance(){return c.instance||(c.instance=new c),c.instance}register(e){this.handlers.set(e.method,e),console.log(`RPCMethodRegistry: Registered handler for ${e.method}`)}async execute(e,t=[],r={}){const a=this.handlers.get(e);if(!a)throw this.createError(-32601,`Method ${e} not found`);try{a.permissions&&a.permissions.length>0&&await this.checkPermissions(a.permissions,r),console.log(`RPCMethodRegistry: Executing ${e} with params:`,t);const s=await a.handler(t,r);return console.log(`RPCMethodRegistry: ${e} result:`,s),s}catch(t){if(console.error(`RPCMethodRegistry: Error executing ${e}:`,t),t instanceof Error&&"code"in t)throw t;throw this.createError(n,t instanceof Error?t.message:"Unknown error")}}getRegisteredMethods(){return Array.from(this.handlers.keys())}isMethodSupported(e){return this.handlers.has(e)}createError(e,t,r){const a=new Error(t);return a.code=e,a.message=t,void 0!==r&&(a.data=r),a}registerBuiltInMethods(){this.register({method:"eth_accounts",handler:this.handleEthAccounts.bind(this),permissions:[],description:"Get current accounts"}),this.register({method:"eth_requestAccounts",handler:this.handleEthRequestAccounts.bind(this),permissions:[],description:"Request access to accounts"}),this.register({method:"eth_chainId",handler:this.handleEthChainId.bind(this),permissions:[],description:"Get current chain ID"}),this.register({method:"net_version",handler:this.handleNetVersion.bind(this),permissions:[],description:"Get network version"}),this.register({method:"wallet_switchEthereumChain",handler:this.handleWalletSwitchChain.bind(this),permissions:["connected"],description:"Switch to a different Ethereum chain"}),this.register({method:"wallet_addEthereumChain",handler:this.handleWalletAddChain.bind(this),permissions:["connected"],description:"Add a new Ethereum chain"}),this.register({method:"eth_getBalance",handler:this.handleEthGetBalance.bind(this),permissions:["connected"],description:"Get account balance"}),this.register({method:"eth_getTransactionCount",handler:this.handleEthGetTransactionCount.bind(this),permissions:["connected"],description:"Get transaction count (nonce)"}),this.register({method:"eth_sendTransaction",handler:this.handleEthSendTransaction.bind(this),permissions:["connected"],description:"Send a transaction"}),this.register({method:"eth_signTransaction",handler:this.handleEthSignTransaction.bind(this),permissions:["connected"],description:"Sign a transaction"}),this.register({method:"personal_sign",handler:this.handlePersonalSign.bind(this),permissions:["connected"],description:"Sign a message"}),this.register({method:"eth_sign",handler:this.handleEthSign.bind(this),permissions:["connected"],description:"Sign data"})}async handleEthAccounts(e,t){const r=await this.storageService.get("wallets"),a=await this.storageService.get("selectedWallet");return r&&0!==r.length&&a?[a.address]:[]}async handleEthRequestAccounts(e,t){if(t.origin){const e=(await this.storageService.get("connectedSites")||[]).find(e=>e.url===t.origin);if(e)return[e.account]}if(0===(await this.handleEthAccounts(e,t)).length)throw this.createError(i,"No accounts available. Please create or import a wallet first.");if(t.origin&&t.tabId)return await this.requestConnectionApproval(t.origin,t.tabId);throw this.createError(i,"Connection request requires valid origin")}async requestConnectionApproval(e,t){try{const r=new URL(e).hostname;let a="";try{a=(await chrome.tabs.get(t)).favIconUrl||""}catch(e){console.log("Could not get site icon:",e)}const s=`conn_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,n={...(await chrome.storage.local.get(["appState"])).appState||{},currentView:"connect-dapp",connectDAppRequest:{requestId:s,origin:e,siteName:r,siteIcon:a,tabId:t,timestamp:Date.now()}};return await chrome.storage.local.set({appState:n}),await chrome.action.openPopup(),new Promise((t,r)=>{const a=setTimeout(()=>{r(this.createError(4001,"Connection request timed out"))},12e4),n=(i,o,c)=>{"CONNECTION_APPROVED"===i.type&&i.data?.requestId===s?(clearTimeout(a),chrome.runtime.onMessage.removeListener(n),this.addConnection(e,i.data.account).then(()=>{t([i.data.account])}).catch(r)):"CONNECTION_REJECTED"===i.type&&i.data?.requestId===s&&(clearTimeout(a),chrome.runtime.onMessage.removeListener(n),r(this.createError(4001,"User rejected the connection request")))};chrome.runtime.onMessage.addListener(n)})}catch(e){throw console.error("Error requesting connection approval:",e),this.createError(n,"Failed to request connection approval")}}async handleEthChainId(e,t){const r=await this.networkManager.getSelectedNetwork();return r?this.networkManager.chainIdToHex(r.chainId):"0x1"}async handleNetVersion(e,t){const r=await this.networkManager.getSelectedNetwork();return r?r.chainId.toString():"1"}async handleWalletSwitchChain(e,t){if(!e[0]||!e[0].chainId)throw this.createError(s,"Missing chainId parameter");try{const t=this.networkManager.parseChainId(e[0].chainId),r=await this.networkManager.findNetworkByChainId(t);if(!r)throw this.createError(5001,`Unrecognized chain ID "${e[0].chainId}". Try adding the chain using wallet_addEthereumChain first.`);return await this.networkManager.switchNetwork(r),null}catch(e){if(e instanceof Error&&"code"in e)throw e;throw this.createError(n,"Failed to switch chain")}}async handleWalletAddChain(e,t){if(!e[0])throw this.createError(s,"Missing chain parameters");try{return await this.networkManager.addCustomNetwork(e[0]),null}catch(e){if(e instanceof Error&&e.message.includes("already exists"))return null;throw this.createError(n,"Failed to add chain")}}async handleEthGetBalance(e,t){return"0x0"}async handleEthGetTransactionCount(e,t){return"0x0"}async handleEthSendTransaction(e,t){throw this.createError(o,"Transaction sending not yet implemented")}async handleEthSignTransaction(e,t){throw this.createError(o,"Transaction signing not yet implemented")}async handlePersonalSign(e,t){throw this.createError(o,"Message signing not yet implemented")}async handleEthSign(e,t){throw this.createError(o,"Data signing not yet implemented")}async checkPermissions(e,t){if(e.includes("connected")&&t.origin&&!(await this.storageService.get("connectedSites")||[]).some(e=>e.url===t.origin))throw this.createError(i,"The requested account and/or method has not been authorized by the user.")}async addConnection(e,t){const r=await this.storageService.get("connectedSites")||[];if(!r.find(t=>t.url===e)){const a=await this.networkManager.getSelectedNetwork(),s={url:e,account:t,chainId:a?.chainId||1,lastUsed:Date.now(),permissions:["connected"]};r.push(s),await this.storageService.set("connectedSites",r),console.log(`RPCMethodRegistry: Added connection for ${e}`)}}}class l{static async initialize(){console.log("ClearWalletCore: Initializing core services...");try{await this.storage.initialize(),this.setupEventListeners(),console.log("ClearWalletCore: Core services initialized successfully")}catch(e){throw console.error("ClearWalletCore: Failed to initialize core services:",e),e}}static setupEventListeners(){this.networks.on("networkChanged",e=>{console.log("ClearWalletCore: Network changed event:",e)}),this.wallets.on("walletSelected",e=>{console.log("ClearWalletCore: Wallet selected event:",e)})}static getStatus(){return{storage:this.storage.getCacheInfo(),networks:!0,wallets:!0,rpc:this.rpc.getRegisteredMethods()}}}l.storage=t.getInstance(),l.networks=r.getInstance(),l.wallets=a.getInstance(),l.rpc=c.getInstance()})();