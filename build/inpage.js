(()=>{"use strict";!function(){if(window.ethereum&&window.ethereum.isClearWallet)return void console.log("ClearWallet: Already injected");console.log("ClearWallet: Injecting provider...");let e=0;const t=new Map;let n=!1;const s=new class{constructor(){this.isClearWallet=!0,this.isMetaMask=!0,this.selectedAddress=null,this.chainId="0x1",this.networkVersion="1",this._isConnected=!1,this._isAuthorized=!1,this._eventListeners=new Map,this.initialize()}get _metamask(){return{isUnlocked:()=>Promise.resolve(this._isConnected),requestBatch:()=>Promise.reject(new Error("Batch requests not supported"))}}get _version(){return"11.0.0"}isConnected(){return this._isConnected}async request(e){const{method:t,params:n=[]}=e;if(!t||"string"!=typeof t)throw this.createError(4200,"Method is not a valid string");switch(console.log(`ClearWallet: Request ${t}`,n),t){case"eth_chainId":return this.chainId;case"net_version":return this.networkVersion;case"eth_accounts":return this._isAuthorized&&this.selectedAddress?[this.selectedAddress]:[]}if(!this.isConnected()&&"eth_requestAccounts"!==t)throw this.createError(4900,"Provider is disconnected from all chains");if(["eth_sendTransaction","personal_sign","eth_signTypedData_v4","wallet_switchEthereumChain","wallet_addEthereumChain"].includes(t)&&!this._isAuthorized)throw this.createError(4100,"The requested method and/or account has not been authorized by the user");return this.sendRequestToBackground(t,n)}on(e,t){this._eventListeners.has(e)||this._eventListeners.set(e,[]),this._eventListeners.get(e).push(t)}removeListener(e,t){const n=this._eventListeners.get(e);if(n){const e=n.indexOf(t);e>-1&&n.splice(e,1)}}enable(){return console.warn('ethereum.enable() is deprecated. Use ethereum.request({method: "eth_requestAccounts"}) instead.'),this.request({method:"eth_requestAccounts"})}send(e,t){return console.warn("ethereum.send() is deprecated. Use ethereum.request() instead."),this.request({method:e,params:t})}sendAsync(e,t){console.warn("ethereum.sendAsync() is deprecated. Use ethereum.request() instead."),this.request(e).then(n=>t(null,{id:e.id,jsonrpc:"2.0",result:n})).catch(e=>t(e,null))}async sendRequestToBackground(n,s){return new Promise((i,r)=>{const o=++e;t.set(o,{resolve:i,reject:r});const a={type:"CLEARWALLET_ETH_REQUEST",data:{method:n,params:s},id:o};console.log("ClearWallet: Sending request:",a),window.postMessage(a,"*"),setTimeout(()=>{t.has(o)&&(t.delete(o),r(this.createError(4900,"Request timeout")))},3e4)})}createError(e,t,n){const s=new Error(t);return s.code=e,void 0!==n&&(s.data=n),s}emit(e,t){const n=this._eventListeners.get(e);n&&n.forEach(e=>{try{e(t)}catch(e){console.error("ClearWallet: Error in event listener:",e)}})}initialize(){window.addEventListener("message",e=>{if(e.source!==window)return;const{type:s,data:i,id:r}=e.data;if("CLEARWALLET_CONTENT_SCRIPT_READY"===s)return n=!0,console.log("ClearWallet: Content script ready"),void this.checkExistingConnection();if("CLEARWALLET_ETH_REQUEST_RESPONSE"===s&&t.has(r)){const{resolve:e,reject:n}=t.get(r);return t.delete(r),void(i.error?i.error.includes&&i.error.includes("rejected")?n(this.createError(4001,"User rejected the request")):n(this.createError(4100,i.error)):(i.accounts&&i.accounts.length>0&&(this.selectedAddress=i.accounts[0],this.chainId=i.chainId||this.chainId,this.networkVersion=this.chainId?parseInt(this.chainId,16).toString():"1",this._isConnected=!0,this._isAuthorized=!0,this.emit("connect",{chainId:this.chainId}),this.emit("accountsChanged",i.accounts)),e(i.accounts||i.result||i)))}switch(s){case"CLEARWALLET_CONNECTION_SUCCESS":case"CONNECTION_SUCCESS":this.handleConnectionSuccess(i);break;case"CLEARWALLET_ACCOUNT_CHANGED":case"ACCOUNT_CHANGED":this.handleAccountChanged(i);break;case"CLEARWALLET_CHAIN_CHANGED":case"CHAIN_CHANGED":this.handleChainChanged(i);break;case"CLEARWALLET_WALLET_DISCONNECTED":case"WALLET_DISCONNECTED":this.handleDisconnected()}})}async checkExistingConnection(){try{const t={type:"CLEARWALLET_CHECK_CONNECTION",data:{origin:window.location.origin},id:++e};window.postMessage(t,"*")}catch(e){console.log("ClearWallet: No existing connection")}}handleConnectionSuccess(e){console.log("ClearWallet: Connection success!",e),this.selectedAddress=e.account,this.chainId=e.chainId,this.networkVersion=e.chainId?parseInt(e.chainId,16).toString():"1",this._isConnected=!0,this._isAuthorized=!0,this.emit("connect",{chainId:e.chainId}),this.emit("accountsChanged",[e.account])}handleAccountChanged(e){this.selectedAddress=e.accounts[0]||null,this.emit("accountsChanged",e.accounts)}handleChainChanged(e){this.chainId=e.chainId,this.networkVersion=e.chainId?parseInt(e.chainId,16).toString():"1",this.emit("chainChanged",e.chainId)}handleDisconnected(){this.selectedAddress=null,this._isConnected=!1,this._isAuthorized=!1,this.emit("disconnect"),this.emit("accountsChanged",[])}};window.ethereum&&window.ethereum!==s&&!window.ethereum.isClearWallet&&(window.ethereum_backup=window.ethereum),Object.defineProperty(window,"clearwallet",{value:s,writable:!1,configurable:!1}),window.clearwallet_priority?console.log("ClearWallet: Have priority, installing provider"):console.log("ClearWallet: No priority flag, installing anyway"),Object.defineProperty(window,"ethereum",{value:s,writable:!1,configurable:!0}),console.log("ClearWallet: Provider installed as window.ethereum and window.clearwallet"),console.log("ClearWallet: window.ethereum =",window.ethereum),console.log("ClearWallet: window.ethereum.isClearWallet =",window.ethereum?.isClearWallet),window.dispatchEvent(new Event("ethereum#initialized")),window.dispatchEvent(new CustomEvent("eip6963:announceProvider",{detail:{info:{uuid:"clearwallet-"+crypto.randomUUID(),name:"ClearWallet",icon:"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiI+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiMzYjgyZjYiLz48L3N2Zz4=",rdns:"io.clearwallet"},provider:s}})),console.log("ClearWallet: Provider injected successfully")}()})();