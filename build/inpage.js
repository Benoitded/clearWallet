(()=>{"use strict";!function(){if(window.ethereum&&window.ethereum.isClearWallet)return void console.log("ClearWallet: Already injected");console.log("ClearWallet: Injecting provider...");let e=0;const t=new Map;let n=!1;const s=4900,i=new class{constructor(){this.isClearWallet=!0,this.isMetaMask=!0,this.selectedAddress=null,this.chainId="0x1",this.networkVersion="1",this._isConnected=!1,this._isAuthorized=!1,this._eventListeners=new Map,this.initialize()}get _metamask(){return{isUnlocked:()=>Promise.resolve(this._isConnected),requestBatch:()=>Promise.reject(new Error("Batch requests not supported"))}}get _version(){return"11.0.0"}isConnected(){return this._isConnected}async request(e){const{method:t,params:n=[]}=e;if(!t||"string"!=typeof t)throw this.createError(4200,"Method is not a valid string");switch(console.log(`ClearWallet: Request ${t}`,n),t){case"eth_chainId":return this.chainId;case"net_version":return this.networkVersion;case"eth_accounts":return this._isAuthorized&&this.selectedAddress?[this.selectedAddress]:[]}if(!this.isConnected()&&"eth_requestAccounts"!==t)throw this.createError(s,"Provider is disconnected from all chains");if(["eth_sendTransaction","personal_sign","eth_signTypedData_v4","wallet_switchEthereumChain","wallet_addEthereumChain"].includes(t)&&!this._isAuthorized)throw this.createError(4100,"The requested method and/or account has not been authorized by the user");return this.sendRequestToBackground(t,n)}on(e,t){this._eventListeners.has(e)||this._eventListeners.set(e,[]),this._eventListeners.get(e).push(t)}removeListener(e,t){const n=this._eventListeners.get(e);if(n){const e=n.indexOf(t);e>-1&&n.splice(e,1)}}enable(){return console.warn('ethereum.enable() is deprecated. Use ethereum.request({method: "eth_requestAccounts"}) instead.'),this.request({method:"eth_requestAccounts"})}send(e,t){return console.warn("ethereum.send() is deprecated. Use ethereum.request() instead."),this.request({method:e,params:t})}sendAsync(e,t){console.warn("ethereum.sendAsync() is deprecated. Use ethereum.request() instead."),this.request(e).then(n=>t(null,{id:e.id,jsonrpc:"2.0",result:n})).catch(e=>t(e,null))}async sendRequestToBackground(n,i){return new Promise((r,o)=>{const a=++e;t.set(a,{resolve:r,reject:o});const c={type:"CLEARWALLET_ETH_REQUEST",data:{method:n,params:i},id:a};console.log("ClearWallet: Sending request:",c),window.postMessage(c,"*"),setTimeout(()=>{t.has(a)&&(t.delete(a),o(this.createError(s,"Request timeout")))},3e4)})}createError(e,t,n){const s=new Error(t);return s.code=e,void 0!==n&&(s.data=n),s}emit(e,t){const n=this._eventListeners.get(e);n&&n.forEach(e=>{try{e(t)}catch(e){console.error("ClearWallet: Error in event listener:",e)}})}initialize(){window.addEventListener("message",e=>{if(e.source!==window)return;const{type:i,data:r,id:o}=e.data;if("CLEARWALLET_CONTENT_SCRIPT_READY"===i)return n=!0,console.log("ClearWallet: Content script ready"),void this.checkExistingConnection();if("CLEARWALLET_ETH_REQUEST_RESPONSE"===i&&t.has(o)){const{resolve:e,reject:n}=t.get(o);return t.delete(o),void(r&&r.error?"string"==typeof r.error&&r.error.includes("rejected")?n(this.createError(4001,"User rejected the request")):n(this.createError(4100,"string"==typeof r.error?r.error:"Unknown error")):r?(r.accounts&&r.accounts.length>0&&(this.selectedAddress=r.accounts[0],this.chainId=r.chainId||this.chainId,this.networkVersion=this.chainId?parseInt(this.chainId,16).toString():"1",this._isConnected=!0,this._isAuthorized=!0,this.emit("connect",{chainId:this.chainId}),this.emit("accountsChanged",r.accounts)),e(r.accounts||r.result||r.success||r)):n(this.createError(s,"No response received")))}if("CLEARWALLET_CHECK_CONNECTION_RESPONSE"===i&&t.has(o)){const{resolve:e}=t.get(o);return t.delete(o),void e(r)}switch(i){case"CLEARWALLET_CONNECTION_SUCCESS":case"CONNECTION_SUCCESS":this.handleConnectionSuccess(r);break;case"CLEARWALLET_ACCOUNT_CHANGED":case"ACCOUNT_CHANGED":this.handleAccountChanged(r);break;case"CLEARWALLET_CHAIN_CHANGED":case"CHAIN_CHANGED":this.handleChainChanged(r);break;case"CLEARWALLET_WALLET_DISCONNECTED":case"WALLET_DISCONNECTED":this.handleDisconnected()}})}async checkExistingConnection(){try{const n=++e,s=new Promise((e,s)=>{t.set(n,{resolve:e,reject:s}),setTimeout(()=>{t.has(n)&&(t.delete(n),e(null))},5e3)}),i={type:"CLEARWALLET_CHECK_CONNECTION",data:{origin:window.location.origin},id:n};window.postMessage(i,"*");const r=await s;if(r&&r.connected){const e=r;this.selectedAddress=e.account,this.chainId=e.chainId,this.networkVersion=e.chainId?parseInt(e.chainId,16).toString():"1",this._isConnected=!0,this._isAuthorized=!0,console.log("ClearWallet: Restored existing connection",e),this.emit("connect",{chainId:e.chainId}),this.emit("accountsChanged",[e.account])}}catch(e){console.log("ClearWallet: No existing connection")}}handleConnectionSuccess(e){console.log("ClearWallet: Connection success!",e),this.selectedAddress=e.account,this.chainId=e.chainId,this.networkVersion=e.chainId?parseInt(e.chainId,16).toString():"1",this._isConnected=!0,this._isAuthorized=!0,this.emit("connect",{chainId:e.chainId}),this.emit("accountsChanged",[e.account])}handleAccountChanged(e){this.selectedAddress=e.accounts[0]||null,this.emit("accountsChanged",e.accounts)}handleChainChanged(e){this.chainId=e.chainId,this.networkVersion=e.chainId?parseInt(e.chainId,16).toString():"1",this.emit("chainChanged",e.chainId)}handleDisconnected(){this.selectedAddress=null,this._isConnected=!1,this._isAuthorized=!1,this.emit("disconnect"),this.emit("accountsChanged",[])}};window.ethereum&&window.ethereum!==i&&!window.ethereum.isClearWallet&&(window.ethereum_backup=window.ethereum),Object.defineProperty(window,"clearwallet",{value:i,writable:!1,configurable:!1}),window.clearwallet_priority?console.log("ClearWallet: Have priority, installing provider"):console.log("ClearWallet: No priority flag, installing anyway"),Object.defineProperty(window,"ethereum",{value:i,writable:!1,configurable:!0}),console.log("ClearWallet: Provider installed as window.ethereum and window.clearwallet"),console.log("ClearWallet: window.ethereum =",window.ethereum),console.log("ClearWallet: window.ethereum.isClearWallet =",window.ethereum?.isClearWallet),window.dispatchEvent(new Event("ethereum#initialized")),window.dispatchEvent(new CustomEvent("eip6963:announceProvider",{detail:{info:{uuid:"clearwallet-"+crypto.randomUUID(),name:"ClearWallet",icon:"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiI+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiMzYjgyZjYiLz48L3N2Zz4=",rdns:"io.clearwallet"},provider:i}})),console.log("ClearWallet: Provider injected successfully")}()})();